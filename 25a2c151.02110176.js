(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{123:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return r})),n.d(t,"default",(function(){return b}));var i=n(1),a=n(6),o=(n(0),n(242)),s=n(244),l={title:"Unit Testing Guide",sidebar_label:"Unit Testing",description:"Learn how to write and execute unit tests for your configs",status:"beta"},c={id:"setup/guides/unit-testing",title:"Unit Testing Guide",description:"Learn how to write and execute unit tests for your configs",source:"@site/docs/setup/guides/unit-testing.md",permalink:"/docs/setup/guides/unit-testing",editUrl:"https://github.com/brainrexapi/edit/master/docs/setup/guides/unit-testing.md",sidebar_label:"Unit Testing",sidebar:"docs",previous:{title:"Getting Started Guide",permalink:"/docs/setup/guides/getting-started"},next:{title:"Troubleshooting Guide",permalink:"/docs/setup/guides/troubleshooting"}},r=[{value:"Input",id:"input",children:[]},{value:"Conditions",id:"conditions",children:[]},{value:"Executing",id:"executing",children:[]}],p={rightToc:r},u="wrapper";function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)(u,Object(i.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"It's possible to define unit tests within a Vector configuration file that cover\na network of transforms within the topology. The purpose of these tests is to\nimprove the maintainability of configs containing larger and more complex\ncombinations of transforms."),Object(o.b)("p",null,"The full spec can be found ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/reference/tests/"}),"here"),". This guide will cover\nwriting and executing a unit test for the following config:"),Object(o.b)(s.a,{fileName:"example.toml",mdxType:"CodeHeader"}),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-toml"}),'[sources.over_tcp]\n  type = "tcp"\n  address = "0.0.0.0:9000"\n\n[transforms.foo]\n  type = "grok_parser"\n  inputs = ["over_tcp"]\n  pattern = "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}"\n\n[transforms.bar]\n  type = "add_fields"\n  inputs = ["foo"]\n  [transforms.bar.fields]\n    new_field = "this is a static value"\n\n[transforms.baz]\n  type = "remove_fields"\n  inputs = ["foo"]\n  fields = ["level"]\n\n[sinks.over_http]\n  type = "http"\n  inputs = ["baz"]\n  uri = "http://localhost:4195/post"\n  encoding = "text"\n')),Object(o.b)("p",null,"In this config we:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Parse a log line into the fields ",Object(o.b)("inlineCode",{parentName:"li"},"timestamp"),", ",Object(o.b)("inlineCode",{parentName:"li"},"level")," and ",Object(o.b)("inlineCode",{parentName:"li"},"message")," with the\ntransform ",Object(o.b)("inlineCode",{parentName:"li"},"foo"),"."),Object(o.b)("li",{parentName:"ul"},"Add a static string field ",Object(o.b)("inlineCode",{parentName:"li"},"new_field")," using the transform ",Object(o.b)("inlineCode",{parentName:"li"},"bar"),"."),Object(o.b)("li",{parentName:"ul"},"Remove the field ",Object(o.b)("inlineCode",{parentName:"li"},"level")," with the transform ",Object(o.b)("inlineCode",{parentName:"li"},"baz"),".")),Object(o.b)("p",null,"In reality it's unlikely that a config this simple would be worth the investment\nof writing unit tests. Regardless, for the purpose of this guide we've concluded\nthat yes, we do wish to unit test this config."),Object(o.b)("p",null,"Specifically, we need to ensure that the resulting events of our topology\n(whatever comes out of the ",Object(o.b)("inlineCode",{parentName:"p"},"baz")," transform) always meets the following\nrequirements:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Does NOT contain the field ",Object(o.b)("inlineCode",{parentName:"li"},"level"),"."),Object(o.b)("li",{parentName:"ul"},"Contains the field ",Object(o.b)("inlineCode",{parentName:"li"},"new_field"),", with a static value ",Object(o.b)("inlineCode",{parentName:"li"},"this is a static value"),"."),Object(o.b)("li",{parentName:"ul"},"Has a ",Object(o.b)("inlineCode",{parentName:"li"},"timestamp")," and ",Object(o.b)("inlineCode",{parentName:"li"},"message")," field containing the values extracted from the\nraw message of the input log.")),Object(o.b)("p",null,"Otherwise our system fails and an annoying relative (Uncle Cecil) moves in to\nlive with us indefinitely. We will do ",Object(o.b)("em",{parentName:"p"},"anything")," to prevent that."),Object(o.b)("h2",{id:"input"},"Input"),Object(o.b)("p",null,"First we shall write a single unit test at the bottom of our config called\n",Object(o.b)("inlineCode",{parentName:"p"},"check_simple_log"),". Each test must define a single input event, which initiates\nthe test by injecting that event into a transform of the topology:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-toml"}),'[[tests]]\n  name = "check_simple_log"\n\n  [tests.input]\n    insert_at = "foo"\n    type = "raw"\n    value = "2019-11-28T12:00:00+00:00 info Sorry, I\'m busy this week Cecil"\n')),Object(o.b)("p",null,"Here we've specified that our test should begin by injecting an event at the\ntransform ",Object(o.b)("inlineCode",{parentName:"p"},"foo"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"raw")," input type creates a log with only a ",Object(o.b)("inlineCode",{parentName:"p"},"message")," field\nand ",Object(o.b)("inlineCode",{parentName:"p"},"timestamp")," (set to the time of the test), where ",Object(o.b)("inlineCode",{parentName:"p"},"message")," is populated with\nthe contents of the ",Object(o.b)("inlineCode",{parentName:"p"},"value")," field."),Object(o.b)("h2",{id:"conditions"},"Conditions"),Object(o.b)("p",null,"This test won't work in its current state because there's nothing to check. In\norder to perform checks with this unit test we define an expected output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-toml"}),'[[tests]]\n  name = "check_simple_log"\n\n  [tests.input]\n    insert_at = "foo"\n    type = "raw"\n    value = "2019-11-28T12:00:00+00:00 info Sorry, I\'m busy this week Cecil"\n\n  [[tests.outputs]]\n    extract_from = "baz"\n\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "level.exists" = false\n      "new_field.equals" = "this is a static value"\n      "timestamp.equals" = "2019-11-28T12:00:00+00:00"\n      "message.equals" = "Sorry, I\'m busy this week Cecil"\n')),Object(o.b)("p",null,"You can define any number of expected outputs, where we must specify at which\ntransform the output events should be extracted for checking. This allows you to\ncheck the events from different transforms in a single test. For our purposes we\nonly need to check the output of ",Object(o.b)("inlineCode",{parentName:"p"},"baz"),"."),Object(o.b)("p",null,"An output can also have any number of conditions to check. In order for the test\nto pass each condition for an output must resolve to ",Object(o.b)("inlineCode",{parentName:"p"},"true"),". It's possible for a\ntopology to result in >1 events extracted from a single transform, in which case\na condition must pass for one or more of the extracted events in order for the\ntest to pass."),Object(o.b)("p",null,"The only condition we've defined here is a ",Object(o.b)("inlineCode",{parentName:"p"},"check_fields")," type. This is\ncurrently the ",Object(o.b)("em",{parentName:"p"},"only")," condition type on offer, and it allows us to specify any\nnumber of field queries (of the format ",Object(o.b)("inlineCode",{parentName:"p"},'"<field>.<predicate>" = "<argument>"'),")."),Object(o.b)("h2",{id:"executing"},"Executing"),Object(o.b)("p",null,"With this test appended to the bottom of our config we are now able to execute\nit. Executing tests within a config file can be done with the ",Object(o.b)("inlineCode",{parentName:"p"},"test")," subcommand:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-bash"}),"vector test ./example.toml\n")),Object(o.b)("p",null,"Doing this results in the following output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-sh"}),'$ vector test ./example.toml\nRunning ./example.toml tests\nTest ./example.toml: check_simple_log ... failed\n\nfailures:\n\n--- ./example.toml ---\n\nTest \'check_simple_log\':\ncheck transform \'baz\' failed conditions: [ 0 ], payloads (encoded in JSON format):\n  {"timestamp":"2019-11-28T12:00:00+00:00","message":"Sorry, I\'m busy this week Cecil"}\n')),Object(o.b)("p",null,"Woops! Something isn't right. Unfortunately we're only told which\noutput-condition failed, not which predicate of our ",Object(o.b)("inlineCode",{parentName:"p"},"check_fields")," condition\nspecifically caused the failure. If we refactor our test slightly we can make it\nclearer by breaking our condition down to one per predicate:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-toml"}),'[[tests]]\n  name = "check_simple_log"\n\n  [tests.input]\n    insert_at = "foo"\n    type = "raw"\n    value = "2019-11-28T12:00:00+00:00 info Sorry, I\'m busy this week Cecil"\n\n  [[tests.outputs]]\n    extract_from = "baz"\n\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "level.exists" = false\n\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "new_field.equals" = "this is a static value"\n\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "timestamp.equals" = "2019-11-28T12:00:00+00:00"\n\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "message.equals" = "Sorry, I\'m busy this week Cecil"\n')),Object(o.b)("p",null,"Running the test again gives us this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-sh"}),'$ vector test ./example.toml\nRunning ./example.toml tests\nTest ./example.toml: check_simple_log ... failed\n\nfailures:\n\n--- ./example.toml ---\n\nTest \'check_simple_log\':\ncheck transform \'baz\' failed conditions: [ 1 ], payloads (encoded in JSON format):\n  {"timestamp":"2019-11-28T12:00:00+00:00","message":"Sorry, I\'m busy this week Cecil"}\n')),Object(o.b)("p",null,"This time the output states that it's condition ",Object(o.b)("inlineCode",{parentName:"p"},"1")," that failed, which is the\ncondition checking for the field ",Object(o.b)("inlineCode",{parentName:"p"},"new_field"),". Try reviewing our config topology\nto see if you can spot the mistake."),Object(o.b)("p",null,"SPOILERS: The problem is that transform ",Object(o.b)("inlineCode",{parentName:"p"},"baz")," is configured with the input\n",Object(o.b)("inlineCode",{parentName:"p"},"foo"),", which means ",Object(o.b)("inlineCode",{parentName:"p"},"bar")," is skipped in the topology!"),Object(o.b)("p",null,"Side note: We would have also caught this particular issue with\n",Object(o.b)("inlineCode",{parentName:"p"},"vector validate --topology ./example.toml"),"."),Object(o.b)("p",null,"The fix is easy, we simply change the input of ",Object(o.b)("inlineCode",{parentName:"p"},"baz")," from ",Object(o.b)("inlineCode",{parentName:"p"},"foo")," to ",Object(o.b)("inlineCode",{parentName:"p"},"bar"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-diff"}),'--- a/example.toml\n+++ b/example.toml\n@@ -15,7 +15,7 @@\n\n [transforms.baz]\n   type = "remove_fields"\n-  inputs = ["foo"]\n+  inputs = ["bar"]\n   fields = ["level"]\n')),Object(o.b)("p",null,"And running our test again gives us an exit status 0:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-sh"}),"$ vector test ./example.toml\nRunning ./example.toml tests\nTest ./example.toml: check_simple_log ... passed\n")),Object(o.b)("p",null,"The test passed! Now if we configure our CI system to execute our test we can\nensure that Uncle Cecil remains in Shoreditch after any future config change.\nWhat an insufferable hipster he is."))}b.isMDXComponent=!0}}]);